# High-level API

This API provides objects representing [databases](#database), [tables](#table), [items](#item), [batches](#batch), [queries](#query), and [scans](#scan).

<a name="database"></a>
## Database

### db.fetch(_callback_)

This populates the `db.tables` object with all of the tables in the database.

```javascript
db.fetch(function(err) {
  if (err) return console.error(err)

  var tableCount = Object.keys(db.tables).length

  console.log("This database has %s tables.", tableCount)
})
```

### db.put(_tableName_, _item_)

An alias for `db.get(tableName).put(item)`.

### db.add(_table_)

Returns a table on which `.save()` can be called

```javascript
db.add({
    name: "myTable",
    schema: {id: String, date: Number},
    throughput: {read: 10, write: 10}
  })
  .save(function(err, table){ ... })
```

The `name` is required, but `schema` will default to `{id: String}` and `throughput` will default to the DynamoDB minimums of `3` for reads and `5` for writes.

Note that the order in which the schema keys are defined is important; the first is required and is used as the hash key, while the second is optional and is used as the range key.

### db.remove(_tableName_, _callback_)

An alias for `db.get(tableName).destroy(callback)`

### table = db.get(_tableName_)

Returns a [table](#table).

### item = db.get(_tableName_, _itemKey_)

An alias for `db.get(_tableName_).get(_itemKey_)`.

### batch = db.get([_object_])
### batch = db.get([_function_])

Creates a [batch](#batch) for fetching multiple items from multiple tables.

<a name="table"></a>
## Table

### table.fetch(_callback_)

Fetches metadata about a table, including its schema, throughput, size, and other information.

```
table.fetch(function(err, table) {
  if (err) return console.error(err)

  console.log(
    "This table has %s items and was created at %s",
    table.ItemCount,
    table.CreationDateTime
  )
})
```

### table.destroy(_callback_)

This deletes a table. Note that it may take up to a minute for DynamoDB to actually delete the table.

```javascript

table.destroy(function(err) {
  if (err) return console.error(err)

  console.log("Table is now being deleted.")
})
```

## table.watch(_callback_)

This uses `.fetch()` to poll the status of a table until it is stable (not ending in `ING`), and then calls back.

```javascript
table.watch(function(err, table) {
  if (err) return console.error(err)

  console.log("Table is now %s.", table.TableStatus)
})
```

## table.throughput.set(_attrs_).save(_callback_)

This updates the throughput of a table. Note that both a `read` and `write` property need to be specified, and some DynamoDB limitations exist regarding how often table throughput can be updated.

```javascript
table.throughput
     .set({read: 10, write: 10})
     .save(function(err, data) {
        if (err) return console.error(err)

        console.log("Table throughput is now updating...")
     })
```

## item = table.get(_itemKey_)

Returns a reference to the [item](#item) specified by _itemKey_.

## batch = table.get(_function_)

This is a table-specific alias for fetching a [batch](#batch) of multiple items from the same table.

```javascript
table.get(function() {
        this.add("tags", ["foo"])
        this.put("status", "happy")
        this.remove("middleName")
      })
      .fetch(function(err, data){ ... })
```

## table.put(_item_).save(_callback_)

This puts the specified item in the table, overwriting any existing item with the same key. Note that the specified item must contain the hash and range keys.

```javascript
table.put({
        id: "123",
        name: "ralph"
      })
      .save(function(err, data){ ... })
```

## table.scan(_predicates_)

Returns a [scan](#scan) for the given [predicates](#predicates).

## table.query(_predicates_)

Returns a [query](#scan) for the given [predicates](#predicates).

<a name="predicates"></a>
# Predicates

A predicates object represents one or more predicates to be satisfied, for query or scan keys, or item update expectations.

## new Predicates(_predicates_)

This constructor is called automatically for the Table#scan(), Table#query(), and Update#when() methods, to convert shorthand predicates into the more verbose DynamoDB format.

Predicates take this format:

```javascript
{
  attribute1: {comparisonOperator1: comparisonValue1},
  attribute2: {comparisonOperator2: comparisonValue2}
  ...
}
```

DynamoDB predicates are mapped to more JavaScript-friendly versions, as follows.

```javascript
// NOT_NULL []
{ "!=" : null }

// NE [VAL]
{ "!=" : VAL }

// NULL []
{ "==" : null }

// EQ [VAL]
{ "==" : VAL }

// GT [VAL]
{ ">"  : VAL }

// LT [VAL]
{ "<"  : VAL }

// LE [VAL]
{ "<=" : VAL }

// GE [VAL]
{ ">=" : VAL }

// BETWEEN [VAL1, VAL2]
{ "<=" : [VAL1, VAL2] }
{ ">=" : [VAL1, VAL2] }

// CONTAINS [VAL]
{ "contains" : VAL }

// NOT_CONTAINS [VAL]
{ "!contains" : [VAL] }

// BEGINS_WITH [VAL]
{ "startsWith" : [VAL] }

// IN [VAL1, VAL2, VAL3]
{ "in" : [VAL1, VAL2, VAL3] }
```

Note also that `("attributeName")` resolves to `{attributeName: {"!=": null}}` and `("attributeName", "value")` resolves to `{attributeName: {"==": "value"}}`.

<a name="scan"></a>
# Scan

## scan = table.scan(_predicates_)

Scans are created from tables, using a [predicates](#predicates) object. Note that DynamoDB supports multiple predicates for a scan.

```javascript
table.scan({
        name: "dynamo",
        iq: {">=": 100}
      })
      .get(["name", "iq", "status"])
      .count()
      .fetch(function(err, count){ ... })
```

## scan.get(_attributeNames_)

This fetches only the attribute names in the provided array. If this is not called, all attributes are returned.

## scan.count()

This returns the number of items scanned, and cannot be used if `Scan#get()` is called.

## scan.fetch(_callback_)

This performs the scan, calling back with an array of all items that matched the scan.

<a name="query"></a>
# Query

## query = table.query(_predicates_)

Queries are created from tables, using a [predicates](#predicates) object. Note that only two predicates can be specified: the first using `==` for the hash key, and the second using a one of the predicates supported for queries for the range key.

## query.get(_attributeNames_)

This fetches only the attribute names in the provided array. If this is not called, all attributes are returned.

## query.count()

This returns the number of items scanned, and cannot be used if `Query#get()` is called.

## query.reverse()

This performs the query in reverse order.

## query.fetch(_callback_)

This performs the query, calling back with an array of all items that matched the query.

<a name="item"></a>
# Item

## item = db.get(_tableName, _itemKey_)
## item = table.get(_itemKey_)

An can be obtained from a database or table, by specifying the item key. To uniquely identify an item, the item key must have values for both the hash and range keys.

## item.get(_attributeNames_)

This fetches only the attribute names in the provided array. If this is not called, all attributes are returned.

## item.fetch([_options_], _callback_)

This fetches the item. `{consistent: true}` can be specified as the options object to return a consistent read.

## item.update(_function_)

This specifies multiple attribute updates to be performed in a single transaction. The provided function is called with an update object as its `this` context, allowing `PUT`, `ADD`, and `REMOVE` operations to be performed for each attribute.

```javascript
item.update(function() {
  this.add("tags", ["foo"])
  this.put("status", "happy")
  this.remove("middleName")
})
```

## item.when(_predicates_)

This specifies that update is only performed when the given predicate is satisfied. Only `{"==": value}`, `{"==": null}`, and `{"!=": null}` are allowed.

## item.returning(_type_)

This specifies whether the information returned should be before or after the update. The type can be `ALL_OLD` for puts, or `ALL_OLD`, `UPDATED_OLD`, `ALL_NEW`, or `UPDATED_NEW` for updates.

## item.save(_callback_)

This performs a put or update, and calls back with the results.

<a name="batch"></a>
# Batch

DynamoDB allows up to 100 items across multiple tables to be returned with a single call.

## batch = db.get(_function_)
## batch = table.get(_function_)

A batch can be created from a database, or a table (in which case all Batch#get() calls are scoped to the table). The provided function is executed with the batch as its `this` context.

```javascript
db.get(function() {
  this.get("table1", [{id: "123"},{id: "456"}], ["id", "name", "status"])
  this.get("table2", [{id: "123", date: 1329925897205}])
})
```

## batch.get(_tableName_, _itemKey_, [_attributeNames_])

This adds item to the batch. If _attributeNames_ is specified, only those attributes are returned.

## batch.fetch(_callback_)
This fetches the batch and calls back with the results.
